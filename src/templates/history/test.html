<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>backbone</title>

  
  <link rel="stylesheet" type="text/css" href="../../static/bootstrap-v3.0.0-rc1/css/bootstrap.min.css"/>
  <link rel="stylesheet" type="text/css" href="../../static/css/history.css"/>

</head>
<body>  
  
  
  <script src="http://cdnjs.cloudflare.com/ajax/libs/jquery/1.8.2/jquery.min.js" type="text/javascript"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.4.2/underscore-min.js" type="text/javascript"></script>
  <script src="http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.0.0/backbone-min.js"></script>
  <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.10.3/jquery-ui.min.js"></script>


<script type="text/template" id="item-template">

  <div class = 'checkbox'>
    <input type='checkbox' class = 'check' checked='checked'/>
    <a><%=name%></a>
  </div>
</script>


<script type="text/template" id="product-time-template">
  <div class='checked'><%=name%></div>
</script>

<script type="text/template" id="shopping-list-template">
    <div class="module-day" style='height:<%=days%>px'></div>

    <div class='date' id="<%=date%>">
    <%=date%>

    <input data-test="1"  disabled="disabled" class="datepicker"  />
    </div>

        <ul class="sl_products_container">
            <button type="button" class="close popups" >&times;</button>
            <div class='triangle'></div>
        </ul>
    <div class='circle'><div class = 'small-circle'></div></div>
</script>


<script type="text/template" id="category-item">
        <li>
            <h3>
            <div class="icon-download up_down"></div>
            <input class="category_check" type="checkbox" checked = "checked">
              <%=name%>
            </h3>
            <ul>
            </ul>
        </li>
</script>

<div id='accordian-container'>
    <div id='accordian'>
    </div> 
</div>

<div id='timeLine'>
</div> 

 <script type="text/javascript">



$(document).ready(function() {



  //accordion
  
    var docHeight = $(document).height();

    function moveFloatMenu() {
        //TODO: refactor all this its terrible!
        //top position of accordian addad scrollTop position of window
      
        var menuOffset = menuYloc.top + $(this).scrollTop();

            
        if(!this.docHeight){
            console.log(1)
            this.docHeight = $(document).height();
        }
  
        if((parseInt(menuOffset,10) + parseInt($('#accordian').css('height'),10)) > this.docHeight){
            floatMenu = false;
        }
        else {
           floatMenu = true;
        }
        /*
        console.log((parseInt(menuOffset,10) + parseInt($('#accordian').css('height'),10)) +" "+ this.docHeight);
        console.log('scrolltop: '+$(this).scrollTop());
        console.log("menu-offset: "+(parseInt(menuOffset,10)));
        console.log("acc-height:" +parseInt($('#accordian').css('height'),10));
        */

        if (floatMenu){
            $('#accordian').animate({
                top: menuOffset+"px"
            }, {
                duration: 1000,
                queue: false
            });
        }
   
    
    }
    //returns the offset coordinates for the selected elements, relative to the document.
   var menuYloc = $('#accordian').offset();
    //The scroll event occurs when the user scrolls in the specified element
    //the window is scrolled, moveFloatMenu works

    $(window).scroll(function(){
        var menuHeight = ($('#accordian').css('height'))
        moveFloatMenu();
      

    });  

    

  $.ajaxPrefilter( function( options, originalOptions, jqXHR ) {
      options.url = 'http://127.0.0.1:8000/api' + options.url;

});
//************************Models*******************************//


    var Category  = Backbone.Model.extend({

      urlRoot: '/categories/',
      defaults: {
          'products': "nyaka"
      }

    });

    var Product = Backbone.Model.extend({

        defaults: {
            'categoryId' : null,
            'checked' : true,
            'current' : false,
            'lists' : ""
        },

        initialize: function(){
            this.set('categoryId',this.get("category").id);    
        }
     

    });

    var ShoppingList = Backbone.Model.extend({
         defaults: {
        'products' : [],
    },

        urlRoot : '/shopping_lists/'
    });

    


    ///*************Collections**********************/


    var Products = Backbone.Collection.extend({
        model: Product,
        url : '/products/?format=json'

    })

    var Categories = Backbone.Collection.extend({
      model: Category,
      url : '/categories/?format=json' 
    })

    var TimeLine = Backbone.Collection.extend({

      url : '/shopping_lists/',
      comparator: 'date',
      model:ShoppingList,
      
    })

    



    //**********************Views****************************// 



 

    var ProductTimeView = Backbone.View.extend({
        tagName:  "li",
        template : _.template($('#product-time-template').html()),
        initialize: function() {
            this.listenTo(localProducts, 'all', this.render);
        },    
        events: {
          //"click .checked"   : "test"
        },
        render: function() {
   
            this.$el.html(this.template(this.model.toJSON()));

            //міняємо класи взалежності від атрибута моделі 'checked'
       
            var flag = localProducts.where({id:this.model.get('id')[0]});
            //TODO
            //не  працює чому????
            if(flag) {
                this.$el.addClass('show');
                this.$el.removeClass('hide');
            } else {
           
            //console.log(classname)
            //this.$el.toggleClass('show',flag);
            //this.$el.toggleClass('hide',flag);
            this.$el.addClass('hide');
            this.$el.removeClass('show');
         
            }
            return this;
         
       }
        
    })

//КОЖЕН ліст МАЄ СЛУХАТИ СВОЇ ВЛАСНІ ПРОДУКТИ
//модель передається в вид
    var ShoppingListView = Backbone.View.extend({

        className : 'shopping-list',

        defaults: {
            "dates" : 'nyaka' 
        },

        initialize: function(options) {

        //date array for datepicker
        this.dates = options.dates;

         //from some reason each dont work
         //sum will be recount only if change the product of current shopping-list
          var products = this.model.get('products');
          for (var i =0; i < products.length; i++ ){
            this.listenTo(products[i], 'change', this.sumCount);
          }
               },

        events: {

          "mouseenter .circle" : "showPopup",
          "click .popups" : "hidePopup",
          "click .date" : "showDatepicker"

        },

        //object.listenTo(other, event, callback)  ОДИН ОБЄКТ МОЖЕ СЛУХАТИ ІНШИЙ ЯКЩО ВОНИ ВОП ЯЗАНІ
        render : function(){

            var that = this;
            var template = _.template($('#shopping-list-template').html())
            that.$el.html(template(this.model.toJSON()));

            var products = that.model.get('products');  
                _.each(products,function(product){
                    var view = new ProductTimeView({model: product});
                    that.$el.find('.sl_products_container').append(view.render().el);
                });
            that.sumCount();

            return that;
        },

        sumCount: function(){

            var sum =0;
            var pattern = [50,100,200,400,800,1000,1500,2000,3000, 1000000000]
            var products = this.model.get('products');
            var circle = this.$el.find('.circle')
            var smallCircle = this.$el.find('.small-circle')
            _.each(products,function(product){
                if(product.get('checked')){
                    sum+=Number(product.get('price'));
                } 
                //define class of circle
                circle.removeClass();
                circle.addClass('circle');
                for(var i = 0; i < pattern.length; i++) {
                    if(sum < pattern[i]) {
                        circle.addClass('size-' + i);
                        break;
                    }

                }
            })
            smallCircle.text(sum);
            this.checkEmpty();
        },

        showPopup : function(){
            $('#timeLine').find('.sl_products_container').hide();
            this.$el.find('.sl_products_container').show();
        },

        hidePopup : function(){
           this.$el.find('.sl_products_container').hide(); 
        },

        checkEmpty : function(){
            var products = this.model.get('products');
            var visible = []
            for (var i = 0; i < products.length; i++){
                if(products[i].get('checked')) {
                    visible.push(i)
                }
            }
            if(visible.length == 0) {
                this.$el.hide();
            } else {
                this.$el.show();
            }
        },
        avaliableDates: function(date,dates){

        dmy = date.getFullYear() +"-"+ (('0'+(date.getMonth()+1)).slice(-2))+ "-" +(('0'+(date.getDate())).slice(-2));
       
        
          if ($.inArray(dmy, dates) != -1) {
            return [true, "myclass","Available"];
          } else {
            return [false,"myclass","unAvailable"];
          }          
   
        },

        showDatepicker: function() {

            var datePicker = this.$el.find(".datepicker");
            var that = this;

          

                datePicker.datepicker({

                    constrainInput: true,
                    showOn: 'button',
                    buttonText: "",

                    beforeShowDay: function(date){
                       return that.avaliableDates(date, that.dates)
                    },

                    onClose: function (){
                         setTimeout(function(){
                            $(".datepicker").blur();
                         }, 200);
                    },

                    onSelect: function(dateText){

                        $('.date').removeClass('label');
                         $('.date').removeClass('label-warning');

                        var container = $('#timeLine');
                        var scrollTo = $('#'+dateText);
                        var scrollT = scrollTo.offset().top - container.offset().top + container.scrollTop()-80;

                        $('body, html').animate({ scrollTop: scrollT }, 'slow');

                        $('#'+dateText).addClass('label');
                        $('#'+dateText).addClass('label-warning');
                    },

                    dateFormat: 'yy-mm-dd'
                })
           
            datePicker.datepicker('option', {});
            datePicker.datepicker("show");



        },
       

    })



    var TimeLineView = Backbone.View.extend({
        el : '#timeLine',
        render : function(){
            var that= this;
            //that.$el.empty();

            var prod = []
            var timeLine = new TimeLine();
            var nextDate = new Date(); //current date
            timeLine.fetch({ 
                success : function() {
                    //сортуємо моделі по спаданню дати
                    var allDates = timeLine.pluck('date');
         
                    _.each(timeLine.models.reverse(), function(shoppingList){
                            prod = []
                            //populute  current shopping-list with appropriate products
                            var products = shoppingList.get('products');
                            var date = shoppingList.get('date');
                        if (date) {
                            //визначення відстані в днях
                            var time = date.split('-');
                            var curDate = new Date()

                            curDate.setFullYear(time[0],time[1]-1,time[2]);
                 
                            var dumyDade = new Date(nextDate - curDate)
              

                            var days = dumyDade.getDate()*20;
                            nextDate = curDate;
                           
                                for(var i = 0; i < products.length; i++) {
                                    var pr = localProducts.where({"id" : products[i].id})[0]
                                    prod.push(pr)
                                }
                                shoppingList = new ShoppingList()
                                shoppingList.set("products",prod);
                                shoppingList.set("date",date);
                                shoppingList.set("days",days);
                               
                                var shoppingListView = new ShoppingListView({model:shoppingList,dates:allDates});
                           
                                that.$el.append(shoppingListView.render().el);
                        }
                      })
                },
                error : function(){
                    console.log('You are ...')
                }
            });  
        }
    })

   
    var ProductView = Backbone.View.extend({

        tagName:  "li",
        events: {
            // check/uncheck change product model
            "click .check"   : "toggleCheck", 
        },

        render: function() {
            var template = _.template($('#item-template').html())
            this.$el.html(template(this.model.toJSON()));
            return this;

        },
        toggleCheck : function(){
            var flag = this.$el.find('.check').is(':checked');
            //тут ми маємо видаляти анчекнуті продукти з  колекції локалпродакт, або додаємо чекнуті
            //this.model.set('checked',flag);
            if(flag) {
  
                localProducts.add(this.model) 
            } else {
         
                localProducts.remove(this.model)
          
            }
            //кожен внутрішній чекнутий  чекбокс на всякий випадок чекає і зовнішній чекбокс 
            if(flag) {
                this.$el.parents('ul').find('.category_check').prop('checked',true)
            }

        }
    })



    var CategoryView = Backbone.View.extend({
      tagName : 'ul',
      className :'t',
      initialize: function() {
         //from some reason each dont work
         var products = this.model.get('products');
          for (var i =0; i < products.length; i++ ){
            this.listenTo(products[i], 'change', this.uncheck);
          }
        },
      //чекбокс категорії має перевірти чи часом всі його дочірні чекбокси не анчекнуті
       events: {
            "click .category_check"   : "toggleCheck", 
            'click .up_down' : 'up_down'

        },
      //Це трігерає апдейт localProduct i( timeLineView.render() зайвий);
      toggleCheck : function (){

        var checked = this.$el.find('.category_check').is(':checked');

        if (checked){
            this.$el.find('.check').prop('checked', true);

            _.each(this.model.get("products"), function(product){
               product.set("checked",true);

            });
        }
        else{
             this.$el.find('.check').prop('checked', false);

              _.each(this.model.get("products"), function(product){
                product.set("checked",false);

            });
        }

      },

      render: function(){
       that = this
        var template = _.template($('#category-item').html())
        this.$el.append(template(this.model.toJSON()));
        //here we render all products for this category
        _.each (this.model.get("products"), function(product){
              var view = new ProductView({model: product});
              that.$el.find('ul').append(view.render().el);
        });
        return this;

      },
      //анчекає категорію, в якій немає чекнутих продуктів
    uncheck: function(){

        var checked = this.$el.find('.check').is(':checked');
        if(checked.length == 0) {
            this.$el.find('.category_check').prop('checked',false);
        }
    },
        up_down : function (){
            if(this.$el.flag === 1) {
 

            this.$el.find('ul').slideUp();
            this.$el.find('.up_down').removeClass('icon-upload')
            this.$el.find('.up_down').addClass('icon-download')
            this.$el.flag = 0;

            } 

            else {
                this.$el.find('ul').slideDown();
                this.$el.flag = 1;
                this.$el.find('.up_down').removeClass('icon-download')
                this.$el.find('.up_down').addClass('icon-upload')
            }
        }


    })

    //робоча версія
    var MenuView = Backbone.View.extend({
        el : "#accordian",
        events: {
            
        },
        render : function(){
            var that = this;

            localCategories.fetch({
                success: function(){
         
                      //underscore foreach
                      _.each(localCategories.models, function(category){

                            //populate  current catergory with appropriate products
                            var products = localProducts.where({"categoryId":category.id});

                            category.set("products",products);

                            var categoryView = new CategoryView({model:category});
                            that.$el.append(categoryView.render().el);
                            
                      })

                       //КОЛИ Я ДОБАВЛЯЮ МОДЕЛІ В КОЛЕКЦІЮ КОЖЕНА МОДЕЛЬ ОТРИМУЄ 21 ВКЛАДЕННЯ КЛЕКЦІЙ (Є 21 ПРОДУКТ)
                      //Я ПРОСТО НЕ УСВІДОМЛЮЮ, ЩО ЦЕ
                      //Michael: Проблема і далі актуальна, але на функціоналність не впливає

                }

                    });
         
    
        }
    })


     
    var localProducts = new  Products(); 
    //var localShoppingLists = new  ShoppingLists(); 
    var localCategories = new Categories(); 

   //Рендеримо меню коли дочекаємось завантаження колекції продуктів
    localProducts.fetch({
        success: function(){

            var menuView = new MenuView();
            menuView.render();

            var timeLineView = new TimeLineView();
            timeLineView.render();
        }
    });


   
//продукти зникають по анчеку+
//продукти  з являлися по чеку +
//потрібно зробити, щоб shopping-list рахував суми+
//потрібно, щоб виводилася дата+
//*потрібно вибирати тільки ті лісти в яких є дата
//класи кружочків+

//відстані між кружочками*****+



//якщо всі продукти категорії порожні -- категорія анчекається+
//якщо хоч один продукт категорії чекнутий -- категорія чекнута+


//зникнення і поява шоппінг ліст по наведенні+
//зникнення шоппінг ліст по кліку на кнопку - хрестик+
//перевірка кружочків на порожність -- порожній кружок зникає +



//shopping-list  профільтрований по порядку +, 
//не містить list з відсутньою датою
//помісти цифри по центру
})

    </script>

</body>
</html>
